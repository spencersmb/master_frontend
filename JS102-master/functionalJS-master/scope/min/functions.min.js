!function(){describe("Function Exercises",function(){var e;beforeEach(function(){e=null}),it("a function has access to its own local scope variables",function(){var t=function(){var t="inner";e=t};t(),expect("inner"===e).to.be.true}),it("inputs to a function are treated as local scope variables",function(){var t=function(t){e=t};t("inner"),expect("inner"===e).to.be.true}),it("a function has access to the variables contained within the same scope that function was created in",function(){var t="outer",n=function(){e=t};n(),expect("outer"===e).to.be.true}),it("a function's local scope variables are not available anywhere outside that function",function(){var t=function(){};t(),expect(function(){e=localToFirstFn}).to.throw(),expect(null===e).to.be.true}),it("a function's local scope variables are not available anywhere outside that function, regardless of the context it's called in",function(){var t=function(){n()},n=function(){e=localToFirstFn};expect(function(){n()}).to.throw(),expect(function(){t()}).to.throw(),expect(null===e).to.be.true}),it("if an inner and an outer variable share the same name, and the name is referenced in the inner scope, the inner scope variable masks the variable from the outer scope with the same name. This renders the outer scope variables inaccassible from anywhere within the inner function block",function(){var t=function(){var t="inner";e=t};t(),expect("inner"===e).to.be.true}),it("if an inner and an outer variable share the same name, and the name is referenced in the outer scope, the outer value binding will be used",function(){var t="outer",n=function(){};n(),e=t,expect("outer"===e).to.be.true}),it("a new variable scope is created for every call to a function, as exemplified with a counter",function(){var t=function(){var t=t||10;t+=1,e=t};t(),expect(11===e).to.be.true,t(),expect(11===e).to.be.true}),it("a new variable scope is created for each call to a function, as exemplified with uninitialized string variables",function(){var t=function(){var t;void 0===t?e="alpha":"initialized"===t&&(e="omega"),t="initialized"};t(),expect("alpha"===e).to.be.true,t(),expect("alpha"===e).to.be.true}),it("an inner function can access both its local scope variables and variables in its containing scope, provided the variables have different names",function(){var t="outer",n=function(){var n="inner";e=n+t};n(),expect("innerouter"===e).to.be.true}),it("between calls to an inner function, that inner function retains access to a variable in an outer scope. Modifying those variables has a lasting effect between calls to the inner function.",function(){var t=10,n=function(){t+=1,e=t};n(),expect(11===e).to.be.true,n(),expect(12===e).to.be.true}),it("the rule about retaining access to variables from an outer scope still applies, even after the outer function call (that created the outer scope) has returned",function(){var t=function(){var t=10,n=function(){t+=1,e=t};n(),expect(11===e).to.be.true,n(),expect(12===e).to.be.true,window.retainedInnerFn=n};expect(window.retainedInnerFn).to.equal.undefined,t(),expect(window.retainedInnerFn).to.be.a("function"),window.retainedInnerFn(),expect(13===e).to.be.true})})}();